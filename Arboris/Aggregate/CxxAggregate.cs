using Arboris.Models.Analyze.CXX;
using Arboris.Models.Graph.CXX;
using Arboris.Repositories;
using FluentResults;

namespace Arboris.Aggregate;

public class CxxAggregate(ICxxRepository nodeRepository)
{
    /// <summary>
    /// Add a new node(Define location) to the database
    /// </summary>
    /// <param name="addNode"> AddNode dto </param>
    /// <returns>
    /// 1. Node id
    /// 2. Is node exists
    /// </returns>
    public async Task<(Guid id, bool isExist)> AddDefineNodeAsync(AddNode addNode)
    {
        Result<Guid> checkNodeExistsResult = await nodeRepository.CheckDefineNodeExistsAsync(addNode);
        if (checkNodeExistsResult.IsSuccess)
            return (checkNodeExistsResult.Value, true);
        return (await nodeRepository.AddNodeAsync(addNode), false);
    }

    /// <summary>
    /// Link member Node to class node
    /// </summary>
    /// <param name="projectId"> Project id </param>
    /// <param name="vcProjectName"> Visual studio project name </param>
    /// <param name="classLocation"> Location of class or struct node </param>
    /// <param name="memberId"> Member node id </param>
    /// <returns></returns>
    public Task<Result> LinkMemberAsync(Guid projectId, string vcProjectName, Location classLocation, Guid memberId)
        => nodeRepository.LinkMemberAsync(projectId, vcProjectName, classLocation, memberId);

    /// <summary>
    /// Find node dependency and link to the node
    /// </summary>
    /// <param name="projectId"> Project id </param>
    /// <param name="vcProjectName"> Visual studio project name </param>
    /// <param name="nodeLocation"> Source node location </param>
    /// <param name="fromLocation"> Uesd node location </param>
    /// <returns></returns>
    public Task<Result> LinkDependencyAsync(Guid projectId, string vcProjectName, Location nodeLocation, Location fromLocation)
        => nodeRepository.LinkDependencyAsync(projectId, vcProjectName, nodeLocation, fromLocation);

    /// <summary>
    /// Find node dependency and link to the node
    /// Because clang returns features of operator= under certain conditions that do not meet our requirements.
    /// </summary>
    /// <param name="projectId"> Project id </param>
    /// <param name="vcProjectName"> Visual studio project name </param>
    /// <param name="nodeLocation"> Source node location </param>
    /// <param name="fromLocation"> Uesd node location </param>
    /// <returns></returns>
    public Task<Result> LinkDependencyCallExprOperatorEqualAsync(Guid projectId, string vcProjectName, Location nodeLocation, Location fromLocation)
        => nodeRepository.LinkDependencyCallExprOperatorEqualAsync(projectId, vcProjectName, nodeLocation, fromLocation);

    /// <summary>
    /// Find node type and link to the node
    /// </summary>
    /// <param name="projectId"> Project id </param>
    /// <param name="vcProjectName"> Visual studio project name </param>
    /// <param name="nodeLocation"> Source node location </param>
    /// <param name="typeLocation"> Type node location </param>
    /// <returns></returns>
    public async Task<Result> LinkTypeAsync(Guid projectId, string vcProjectName, Location nodeLocation, Location typeLocation)
    {
        Result<Node> nodeResult = await nodeRepository.GetNodeFromDefineLocationAsync(projectId, vcProjectName, nodeLocation);
        if (nodeResult.IsFailed)
            return nodeResult.ToResult();

        return await nodeRepository.LinkTypeAsync(projectId, vcProjectName, nodeLocation, typeLocation);
    }

    /// <summary>
    /// Get node infos, only class and struct
    /// </summary>
    /// <param name="projectId"> Project id </param>
    /// <param name="vcProjectName"> Visual studio project name </param>
    /// <returns></returns>
    public Task<Result<NodeInfo[]>> GetDistinctClassAndStructNodeInfosAsync(Guid projectId, string vcProjectName)
        => nodeRepository.GetDistinctClassAndStructNodeInfosAsync(projectId, vcProjectName);

    public Task<Result> MoveTypeDeclarationLinkAsync(Guid projectId, NodeInfo nodeInfo)
        => nodeRepository.MoveTypeDeclarationLinkAsync(projectId, nodeInfo);

    /// <summary>
    /// Remove type declarations
    /// </summary>
    /// <param name="projectId"> Project id </param>
    /// <param name="vcProjectName"> Visual studio project name </param>
    /// <returns></returns>
    public Task<Result> RemoveTypeDeclarations(Guid projectId, string vcProjectName)
        => nodeRepository.RemoveTypeDeclarations(projectId, vcProjectName);

    /// <summary>
    /// Update the description of the node, whith the description generated by the LLM
    /// </summary>
    /// <param name="id"> Node id </param>
    /// <param name="description"> Description generated by the LLM </param>
    /// <returns></returns>
    public async Task<Result> UpdateLLMDescriptionAsync(Guid id, string description)
        => await nodeRepository.UpdateLLMDescriptionAsync(id, description);

    public async Task<Result<NodeInfoWithDependency>> GetNodeInfoWithDependencyAsync(Guid nodeId)
    {
        Task<Result<(string? NameSpace, string? Spelling, string? AccessSpecifiers, IReadOnlySet<string>? IncludeStrings, Guid? ClassNodeId)>> GetNodeInfoWithClassIdAsyncTask = nodeRepository.GetNodeInfoWithClassIdAsync(nodeId);
        Task<Result<NodeSourceCode[]>> GetNodeSourceCodeAsyncTask = nodeRepository.GetNodeSourceCodeAsync(nodeId);
        Task<Result<Guid[]>> GetNodeDependenciesIdAsyncTask = nodeRepository.GetNodeDependenciesIdAsync(nodeId);

        await Task.WhenAll(GetNodeInfoWithClassIdAsyncTask, GetNodeSourceCodeAsyncTask, GetNodeDependenciesIdAsyncTask);

        Result<(string? NameSpace, string? Spelling, string? AccessSpecifiers, IReadOnlySet<string>? IncludeStrings, Guid? ClassNodeId)> GetNodeInfoWithClassIdResult = GetNodeInfoWithClassIdAsyncTask.Result;
        Result<NodeSourceCode[]> GetNodeSourceCodeResult = GetNodeSourceCodeAsyncTask.Result;
        Result<Guid[]> GetNodeDependenciesIdResult = GetNodeDependenciesIdAsyncTask.Result;

        if (GetNodeInfoWithClassIdResult.IsFailed)
            return GetNodeInfoWithClassIdResult.ToResult();
        if (GetNodeSourceCodeResult.IsFailed)
            return GetNodeSourceCodeResult.ToResult();
        if (GetNodeDependenciesIdResult.IsFailed)
            return GetNodeDependenciesIdResult.ToResult();

        return new NodeInfoWithDependency(GetNodeSourceCodeResult.Value, GetNodeInfoWithClassIdResult.Value.NameSpace, GetNodeInfoWithClassIdResult.Value.Spelling, GetNodeInfoWithClassIdResult.Value.AccessSpecifiers, GetNodeInfoWithClassIdResult.Value.IncludeStrings, GetNodeInfoWithClassIdResult.Value.ClassNodeId, GetNodeDependenciesIdResult.Value);
    }

    /// <summary>
    /// Update the user description of the node
    /// </summary>
    /// <param name="projectId"> Project id </param>
    /// <param name="vcProjectName"> Visual studio project name </param>
    /// <param name="nameSpace"></param>
    /// <param name="className"></param>
    /// <param name="spelling"></param>
    /// <param name="cxType"></param>
    /// <param name="description"></param>
    /// <returns></returns>
    public Task<Result> UpdateUserDescriptionAsync(Guid projectId, string vcProjectName, string? nameSpace, string? className, string? spelling, string? cxType, string? description)
        => nodeRepository.UpdateUserDescriptionAsync(projectId, vcProjectName, nameSpace, className, spelling, cxType, description);

    public async Task<Result<Guid?>> InsertorUpdateImplementationLocationAsync(AddNode addNode, IReadOnlySet<string>? includeStrings, CancellationToken ct = default)
    {
        if (ct.IsCancellationRequested)
            return Result.Fail("Trigger CancellationRequested");
        if (addNode.DefineLocation is not null)
        {
            Result<Node> node = await nodeRepository.GetNodeFromDefineLocationAsync(addNode.ProjectId, addNode.VcProjectName, addNode.DefineLocation);
            if (node.IsSuccess)
            {
                node.Value.ImplementationsLocation.Add(addNode.ImplementationLocation!);
                Result UpdateResulr = await nodeRepository.UpdateNodeLocationAsync(new(node.Value.Id, node.Value.DefineLocation, node.Value.ImplementationsLocation));
                if (UpdateResulr.IsFailed)
                    return UpdateResulr;
                node.Value.IncludeStrings = includeStrings;
                UpdateResulr = await nodeRepository.UpdateNodeAsync(node.Value);
                if (UpdateResulr.IsFailed)
                    return UpdateResulr;
                return Result.Ok();
            }
            else if (addNode.DefineLocation.SourceCode == null && addNode.ImplementationLocation is not null)
                // 這個情況是在 ExploreAstNode 時，defineLocation == location ? null : defineLocation，使用了 defineLocation 作為 addNode 的 DefineLocation
                // 理論上執行這行前會先使用 await Scan(defineLocation.FilePath, ct) 將 defineLocation 的 Node 加入到資料庫中
                // 但可能因為 Macro 導致沒有新增 node，這會缺少 sourceCode, class關連及其它資訊
                addNode = new(addNode.ProjectId, addNode.VcProjectName, addNode.CursorKindSpelling, addNode.Spelling, addNode.CxType, addNode.NameSpace, addNode.AccessSpecifiers, null, addNode.ImplementationLocation);
        }
        bool isExists = await nodeRepository.CheckImplementationNodeExistsAsync(addNode);
        if (isExists)
            return Result.Ok();
        Guid? nodeId = await nodeRepository.AddNodeAsync(addNode, includeStrings);
        return Result.Ok(nodeId);
    }
}
